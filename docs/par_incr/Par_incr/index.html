<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Par_incr (par_incr.Par_incr)</title><link rel="stylesheet" href="../../odoc.support/odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc 2.2.0"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../odoc.support/highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body class="odoc"><nav class="odoc-nav"><a href="../index.html">Up</a> â€“ <a href="../index.html">par_incr</a> &#x00BB; Par_incr</nav><header class="odoc-preamble"><h1>Module <code><span>Par_incr</span></code></h1><p>A simple library for parallel incremental computations. Based on <a href="https://drive.google.com/file/d/130-sCY1YPzo4j3YAJ7EL9-MflK0l8RmJ/view?pli=1">&quot;Efficient Parallel Self-Adjusting Computation&quot;</a>.</p></header><nav class="odoc-toc"><ul><li><a href="#how-it-works">How it works</a></li><li><a href="#par_incr-module-documentation">Par_incr Module Documentation</a></li></ul></nav><div class="odoc-content"><h3 id="how-it-works"><a href="#how-it-works" class="anchor"></a>How it works</h3><ul><li>Define <a href="Var/index.html#type-t"><code>Var.t</code></a> with certain values.</li><li>Perform <a href="Var/index.html#val-watch"><code>Var.watch</code></a> operation on <a href="Var/index.html#type-t"><code>Var.t</code></a> and change it to <code>incremental</code>.</li><li>Every <code>incremental</code> signifies a computation in itself.</li><li>Use different combinators provided by the library on the <code>incremental</code>s and make even bigger <code>incremental</code>s.</li><li>Obtain value of a certain <code>incremental</code> by running it (a <a href="#val-run"><code>run</code></a> operation is provided by the library).</li><li>Running an <code>'a incremental</code> returns a <code>'a computation</code>.</li><li>When we change some <a href="Var/index.html#type-t"><code>Var.t</code></a> (done with <a href="Var/index.html#val-set"><code>Var.set</code></a> operation), it marks all dependent computations dirty.</li><li>Running <a href="#val-propagate"><code>propagate</code></a> operation on a dirty <code>computation</code> updates its value efficiently.</li><li>Destroy (with <a href="#val-destroy_comp"><code>destroy_comp</code></a> operation) <code>computation</code> when its no more required.</li></ul><h3 id="par_incr-module-documentation"><a href="#par_incr-module-documentation" class="anchor"></a>Par_incr Module Documentation</h3><div class="odoc-spec"><div class="spec type anchored" id="type-t"><a href="#type-t" class="anchor"></a><code><span><span class="keyword">type</span> <span>'a t</span></span></code></div><div class="spec-doc"><p>A <code>'a t</code> holds a value of type <code>'a</code>. This type is opaque and we don't expose any mechanism to change this or modify it. Computations happens by chaining together various combinators provided by the library, all of which operate on <code>'a t</code>.</p></div></div><div class="odoc-spec"><div class="spec type subst anchored" id="type-incremental"><a href="#type-incremental" class="anchor"></a><code><span><span class="keyword">type</span> <span>'a incremental</span></span><span> := <span><span class="type-var">'a</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p>Type <code>'a incremental</code> is an alias for <code>'a t</code>.</p></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-computation"><a href="#type-computation" class="anchor"></a><code><span><span class="keyword">type</span> <span>'a computation</span></span></code></div><div class="spec-doc"><p>A <code>'a computation</code> holds everything necessary to store a computation.</p></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-executor"><a href="#type-executor" class="anchor"></a><code><span><span class="keyword">type</span> executor</span><span> = </span><span>{</span></code><ol><li id="type-executor.run" class="def record field anchored"><a href="#type-executor.run" class="anchor"></a><code><span>run : 'a. <span><span>(<span>unit <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'a</span>)</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'a</span>;</span></code></li><li id="type-executor.par_do" class="def record field anchored"><a href="#type-executor.par_do" class="anchor"></a><code><span>par_do : 'a 'b. <span><span>(<span>unit <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'a</span>)</span> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span>unit <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'b</span>)</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'a</span> * <span class="type-var">'b</span>;</span></code></li></ol><code><span>}</span></code></div><div class="spec-doc"><p>An <code>executor</code> is something that has to be passed while initially running the computation. The reason behind this is, we want to support multiple ways to run computations in parallel and library users can use the one that is best for them.</p><p>Suppose you have your own scheduler built on top of <code>Domains</code> and you don't want to use Domainslib for running tasks. You can very well use it as long as you provide these two <code>run</code> and <code>par_do</code> functions.</p><p>If however you want to use <code>Domainslib</code>, you would have an <code>executor</code> which would look roughly like this:</p><pre class="language-ocaml"><code>module T = Domainslib.Task
let pool = T.setup_pool ~num_domains:(Domain.recommended_domain_count () / 2) ()
let par_runner f = T.run pool f
let par_do l r =
  let lres = T.async pool l in
  let rres = r () in
  (T.await pool lres, rres)
let executor = {run = par_runner; par_do}</code></pre></div></div><div class="odoc-spec"><div class="spec module anchored" id="module-Cutoff"><a href="#module-Cutoff" class="anchor"></a><code><span><span class="keyword">module</span> <a href="Cutoff/index.html">Cutoff</a></span><span> : <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div></div><div class="odoc-spec"><div class="spec module anchored" id="module-Var"><a href="#module-Var" class="anchor"></a><code><span><span class="keyword">module</span> <a href="Var/index.html">Var</a></span><span> : <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div><div class="spec-doc"><p>Defines the type and various operations for modifiable values.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-return"><a href="#val-return" class="anchor"></a><code><span><span class="keyword">val</span> return : <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>return x</code> returns an instance of <code>'a incremental</code> from <code>x</code> of type <code>'a</code>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-map"><a href="#val-map" class="anchor"></a><code><span><span class="keyword">val</span> map : <span>?cutoff:<span><span class="type-var">'b</span> <a href="Cutoff/index.html#type-t">Cutoff.t</a></span> <span class="arrow">&#45;&gt;</span></span> <span>fn:<span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'b</span>)</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>map ~fn a</code> maps the internal value of <code>a</code> to <code>fn</code>. Default <code>cutoff</code> is <code>Phys_equal</code>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-map2"><a href="#val-map2" class="anchor"></a><code><span><span class="keyword">val</span> map2 : 
  <span>?cutoff:<span><span class="type-var">'c</span> <a href="Cutoff/index.html#type-t">Cutoff.t</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span>?mode:<span>[ `Par <span>| `Seq</span> ]</span> <span class="arrow">&#45;&gt;</span></span>
  <span>fn:<span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'c</span>)</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span class="type-var">'b</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="type-var">'c</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>map2 ~fn ?(mode=`Seq) a b</code> is a convenient function to <code>map</code> over two <code>incremental</code>s. If <code>mode</code> is <code>`Seq</code>, it computes <code>a</code> and <code>b</code> sequentially, but if it is <code>`Par</code>, computing <code>a</code> and <code>b</code> happens in parallel (it's ran with <a href="#type-executor"><code>executor</code></a>s <a href="#type-executor.par_do"><code>par_do</code></a> function). Default <code>cutoff</code> is <code>Phys_equal</code>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-combine"><a href="#val-combine" class="anchor"></a><code><span><span class="keyword">val</span> combine : <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'b</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span class="type-var">'a</span> * <span class="type-var">'b</span>)</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>combine a b</code> is useful function to combine two <code>incremental</code>'s into one.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-bind"><a href="#val-bind" class="anchor"></a><code><span><span class="keyword">val</span> bind : <span>fn:<span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> <a href="#type-t">t</a></span>)</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>bind ~fn a</code> calls <code>fn</code> with the value of <code>a</code> and returns that. This lets us build computations that are more dynamic in nature. This is the monadic bind operation for <code>incremental</code>s.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-par"><a href="#val-par" class="anchor"></a><code><span><span class="keyword">val</span> par : <span>left:<span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span>right:<span><span class="type-var">'b</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span class="type-var">'a</span> * <span class="type-var">'b</span>)</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>par ~left:a ~right:b</code> computes <code>a</code> and <code>b</code> in parallel and gives us the result as a new <code>incremental</code> with both values stored as tuple. This uses <a href="#type-executor"><code>executor</code></a>s <a href="#type-executor.par_do"><code>par_do</code></a> function to run <code>left</code> and <code>right</code> in parallel.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-delay"><a href="#val-delay" class="anchor"></a><code><span><span class="keyword">val</span> delay : <span><span>(<span>unit <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="#type-t">t</a></span>)</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>delay f</code> lets us have <code>incremental</code>s that are lazily evaluated.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-value"><a href="#val-value" class="anchor"></a><code><span><span class="keyword">val</span> value : <span><span><span class="type-var">'a</span> <a href="#type-computation">computation</a></span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'a</span></span></code></div><div class="spec-doc"><p><code>value c</code> returns the value/result associated with the computation <code>c</code>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-run"><a href="#val-run" class="anchor"></a><code><span><span class="keyword">val</span> run : <span>executor:<a href="#type-executor">executor</a> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="#type-computation">computation</a></span></span></code></div><div class="spec-doc"><p><code>run ~executor t</code> evaluates <code>t</code> with the provided <a href="#type-executor"><code>executor</code></a>. This stores the result of the computation as well as all the data structures associated with it.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-propagate"><a href="#val-propagate" class="anchor"></a><code><span><span class="keyword">val</span> propagate : <span><span><span class="type-var">'a</span> <a href="#type-computation">computation</a></span> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p><code>propagate c</code> will propagate the changes to all the <a href="Var/index.html#type-t"><code>Var.t</code></a> that the computation <code>c</code> depended on. If there are no changes, it will not do any extra work and returns back right away.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-dump_tree"><a href="#val-dump_tree" class="anchor"></a><code><span><span class="keyword">val</span> dump_tree : <span>string <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-computation">computation</a></span> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p><code>dump_tree file c</code> will dump the computation tree associated with <code>c</code> into <code>file</code>. It dumps the tree in D2 format. See the <a href="https://github.com/terrastruct/d2">instructions</a> for viewing the files.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-destroy_comp"><a href="#val-destroy_comp" class="anchor"></a><code><span><span class="keyword">val</span> destroy_comp : <span><span><span class="type-var">'a</span> <a href="#type-computation">computation</a></span> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p><code>destroy_comp c</code> will destroy the computation associated with <code>c</code>. After destroying, calling <a href="#val-propagate"><code>propagate</code></a> on <code>c</code> will result in an exception. It's necessary to destroy computations that are no longer needed. A computation will be taking up memory and doing unnecessary work if not destroyed.</p></div></div><div class="odoc-spec"><div class="spec module anchored" id="module-Debug"><a href="#module-Debug" class="anchor"></a><code><span><span class="keyword">module</span> <a href="Debug/index.html">Debug</a></span><span> : <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div></div><div class="odoc-spec"><div class="spec module anchored" id="module-Syntax"><a href="#module-Syntax" class="anchor"></a><code><span><span class="keyword">module</span> <a href="Syntax/index.html">Syntax</a></span><span> : <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div><div class="spec-doc"><p>Introduces some convenient operators for <a href="#val-map"><code>map</code></a>, <a href="#val-bind"><code>bind</code></a>, <a href="#val-combine"><code>combine</code></a> and <a href="#val-par"><code>par</code></a> operations.</p></div></div></div></body></html>